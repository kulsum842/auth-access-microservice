auth-ms-bd
---

models/User.js 

1. Mongoose Schema
Defines the structure of user data in MongoDB.
Ensures validation (e.g. required, enum, unique) before saving.

2. JWT Auth Flow & Tokens
refreshToken: Used for secure, long-term session maintenance.
verificationToken, resetPasswordToken: Used for critical email-based actions (verify/reset).

3. Email Flow Support
isVerified, verificationToken: Needed for preventing login before email verification.
resetPasswordExpires: Adds time-bound protection to reset links.

4. timestamps: true
Automatically adds createdAt and updatedAt fields to documents.
Helpful for auditing and debugging.

---

config/db.js 

1. mongoose.connect()
Establishes a connection to your MongoDB database.
useNewUrlParser and useUnifiedTopology are options to avoid deprecation warnings in Mongoose.

2. Environment Variables
process.env.MONGO_URI: Keeps secrets out of your source code (microservice-friendly).
Allows flexibility across dev, staging, and production environments.

3. Fail-Fast Strategy
process.exit(1): Immediately shuts down the server if the DB connection fails.
Prevents your server from running without a valid database connection.

---

utils/sendEmail.js 
1. Nodemailer
A popular Node.js library to send emails via SMTP.
In your case, you're using Gmail‚Äôs SMTP service (smtp.gmail.com under the hood).

2. Environment Variables
EMAIL_USER: Your sender Gmail ID (hidden from code).
EMAIL_PASS: App password (generated via Google Account > Security > App Passwords).
Never use your actual Gmail password.

3. Why This Utility Matters
Reusability: You can send verification emails, password reset links, or even admin notifications using this one function.
Separation of concerns: Keeps your controllers focused on business logic, not mailing.

üîê Note:
If you later deploy your project, Gmail might block SMTP unless you're using an App Password or switch to a provider like:
SendGrid
Mailgun
Amazon SES

---

middleware/authMiddleware.js 

1. JWT (JSON Web Tokens)
After a successful login, the user receives a signed token containing userId and role.
This token is stored on the frontend (in memory/localStorage/cookie).
For every protected API request, the token must be sent in the Authorization header.

2. Middleware authenticate()
Verifies the token‚Äôs validity.
Decodes it and attaches the user info to req.user.
This info can be used in protected routes to get user data or enforce logic.

3. Middleware authorizeRoles()
Implements Role-Based Access Control (RBAC).
Only allows users with specified roles to access certain routes (like admin-only endpoints).

4. Why This Is Good Microservice Practice
Keeps your endpoints secure and modular.
Logic is centralized, easy to test, and reusable across routes.

---

middleware/rateLimiter.js 

1. Why Use Rate Limiting?
Rate limiting protects your backend from:
‚ùå Brute-force attacks on login endpoints
üêç Bot traffic or abuse of public APIs
üî• Denial-of-service (DoS)-like behavior from a single IP

2. Global vs. Login Limiter
globalLimiter (optional): Applies to the entire app ‚Äî useful if your service is public.
loginLimiter: Essential ‚Äî rate-limits the login route to prevent repeated login attempts.

3. Best Practices
In production, consider using Redis or a shared store for rate limiting if you're scaling the service (multiple backend instances).
Tune the window and max settings based on traffic patterns.

---

controllers/authController.js 

üîê JWT Authentication
Access tokens and refresh tokens are generated using JWT.
Refresh tokens are stored in the DB to enable logout and reuse detection.

‚úâÔ∏è Email Verification & Password Reset
Secure token generation with crypto.randomBytes().
Email contains verification or reset link which frontend handles using query params.

üîÅ Refresh Token Rotation
Verifies if the refresh token is valid and matches the one stored in DB.
Prevents token theft and misuse.

üßº Best Practices Followed
No sensitive values hardcoded (everything pulled from .env).
Status codes and messages are clear.
Account verification enforced before login.
Clear separation of concerns: logic in controller, mailing in utility.

---

routes/authRoutes.js

üõ£Ô∏è 1. Route Structuring
All routes start with /api in your main server file.
Each route maps to a controller function (separation of logic and route definitions).

üßë‚Äçüíª 2. Middleware Usage
authenticate ensures the user has a valid access token.
authorizeRoles('admin') restricts access to certain roles (RBAC).
loginLimiter protects the login route from brute-force attacks.

üìÑ 3. .select('-password')
While returning the user object (in /me), we exclude the hashed password field for security.

---

index.js 

| Section                  | Purpose                                                                                      |
| ------------------------ | -------------------------------------------------------------------------------------------- |
| **`dotenv.config()`**    | Loads `.env` environment variables before anything else                                      |
| **CORS Handling**        | Controls which frontend URLs can talk to your backend                                        |
| **Security**             | `helmet`, `cookie-parser`, optional `xss-clean`, and `mongo-sanitize` enhance backend safety |
| **Global Rate Limiting** | Limits all routes to 100 requests per 15 minutes using `express-rate-limit`                  |
| **Error Middleware**     | Catches unhandled errors and sends a clean JSON response                                     |

---

.env

PORT=5000

# MongoDB
MONGO_URI=your_mongo_uri_here

# JWT Secrets
ACCESS_TOKEN_SECRET=your_access_token_secret
REFRESH_TOKEN_SECRET=your_refresh_token_secret
ACCESS_TOKEN_EXPIRES=15m
REFRESH_TOKEN_EXPIRES=7d

# Email (for nodemailer)
EMAIL_USER=your_email@gmail.com
EMAIL_PASS=your_generated_app_password

# Base URLs
BASE_URL=http://localhost:5000
REDIRECT_BASE_URL=http://localhost:5173

# CORS Origins (comma-separated)
CORS_ALLOWED_ORIGINS=http://localhost:5173,http://localhost:3000

---

This backend is a secure, modular Authentication & Access Control Microservice built using Node.js, Express, and MongoDB. It provides a complete user authentication flow including registration, email verification, login, JWT-based access and refresh tokens, forgot/reset password functionality, protected routes, role-based access control (RBAC), and secure logout with refresh token revocation.

Security measures include rate limiting, CORS configuration, helmet for HTTP headers, and support for cookie-based and token-based authentication. It uses Nodemailer for sending verification and password reset emails through Gmail. The microservice is environment-configurable via a .env file, with dynamic CORS origin handling and base URL control for frontend redirection.

The project structure is cleanly organized into models, controllers, middleware, routes, config, and utilities, making it scalable and easy to maintain. The user model supports key fields like verification tokens, reset tokens, and refresh tokens to support secure workflows. All tokens are signed using secure secrets and handled through environment variables. This backend is designed to serve as a foundation for integrating user management into any modern frontend app with minimal setup.

---

*************************************
